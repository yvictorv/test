// Разные движки имеют разные «кодовые имена». Например:

// V8 – в Chrome и Opera.
// SpiderMonkey – в Firefox.
// …Ещё есть «Trident» и «Chakra» для разных версий IE, «ChakraCore» для Microsoft Edge, «Nitro» и «SquirrelFish» для Safari и т.д.

// Как работают движки?
// Движки сложны. Но основы понять легко.

// Движок (встроенный, если это браузер) читает («парсит») текст скрипта.
// Затем он преобразует («компилирует») скрипт в машинный язык.
// После этого машинный код запускается и работает достаточно быстро.
// Движок применяет оптимизации на каждом этапе. Он даже просматривает скомпилированный скрипт во время его работы, анализируя проходящие через него данные, и применяет оптимизации к машинному коду, полагаясь на полученные знания. В результате скрипты работают очень быстро

// В браузере для JavaScript доступно всё, что связано с манипулированием веб-страницами, взаимодействием с пользователем и веб-сервером.

// Например, в браузере JavaScript может:

// Добавлять новый HTML-код на страницу, изменять существующее содержимое, модифицировать стили.
// Реагировать на действия пользователя, щелчки мыши, перемещения указателя, нажатия клавиш.
// Отправлять сетевые запросы на удалённые сервера, скачивать и загружать файлы (технологии AJAX и COMET).
// Получать и устанавливать куки, задавать вопросы посетителю, показывать сообщения.
// Запоминать данные на стороне клиента («local storage»).


// Чего НЕ может JavaScript в браузере?
// Возможности JavaScript в браузере ограничены ради безопасности пользователя. Цель заключается в предотвращении доступа недобросовестной веб-страницы к личной информации или нанесения ущерба данным пользователя.

// Примеры таких ограничений включают в себя:

// JavaScript на веб-странице не может читать/записывать произвольные файлы на жёстком диске, копировать их или запускать программы. Он не имеет прямого доступа к системным функциям ОС.

// Современные браузеры позволяют ему работать с файлами, но с ограниченным доступом, и предоставляют его, только если пользователь выполняет определённые действия, такие как «перетаскивание» файла в окно браузера или его выбор с помощью тега <input>.

// Существуют способы взаимодействия с камерой/микрофоном и другими устройствами, но они требуют явного разрешения пользователя. Таким образом, страница с поддержкой JavaScript не может незаметно включить веб-камеру, наблюдать за происходящим и отправлять информацию в ФСБ.

// Различные окна/вкладки не знают друг о друге. Иногда одно окно, используя JavaScript, открывает другое окно. Но даже в этом случае JavaScript с одной страницы не имеет доступа к другой, если они пришли с разных сайтов (с другого домена, протокола или порта).

// Это называется «Политика одинакового источника» (Same Origin Policy). Чтобы обойти это ограничение, обе страницы должны согласиться с этим и содержать JavaScript-код, который специальным образом обменивается данными.

// Это ограничение необходимо, опять же, для безопасности пользователя. Страница https://anysite.com, которую открыл пользователь, не должна иметь доступ к другой вкладке браузера с URL https://gmail.com и воровать информацию оттуда.

// JavaScript может легко взаимодействовать с сервером, с которого пришла текущая страница. Но его способность получать данные с других сайтов/доменов ограничена. Хотя это возможно в принципе, для чего требуется явное согласие (вы


// Языки «над» JavaScript
// Синтаксис JavaScript подходит не под все нужды. Разные люди хотят иметь разные возможности.

// Это естественно, потому что проекты разные и требования к ним тоже разные.

// Так, в последнее время появилось много новых языков, которые транспилируются (конвертируются) в JavaScript, прежде чем запустятся в браузере.

// Современные инструменты делают транспиляцию очень быстрой и прозрачной, фактически позволяя разработчикам писать код на другом языке, автоматически преобразуя его в JavaScript «под капотом».

// Примеры таких языков:

// CoffeeScript добавляет «синтаксический сахар» для JavaScript. Он вводит более короткий синтаксис, который позволяет писать чистый и лаконичный код. Обычно такое нравится Ruby-программистам.
// TypeScript концентрируется на добавлении «строгой типизации» для упрощения разработки и поддержки больших и сложных систем. Разработан Microsoft.
// Flow тоже добавляет типизацию, но иначе. Разработан Facebook.
// Dart стоит особняком, потому что имеет собственный движок, работающий вне браузера (например, в мобильных приложениях). Первоначально был предложен Google, как замена JavaScript, но на данный момент необходима его транспиляция для запуска так же, как для вышеперечисленных языков.
// Brython транспилирует Python в JavaScript, что позволяет писать приложения на чистом Python без JavaScript.
// Есть и другие. Но даже если мы используем один из этих языков, мы должны знать JavaScript, чтобы действительно понимать, что мы делаем


// Таблицы совместимости
// JavaScript – это развивающийся язык, в который постоянно добавляется что-то новое.

// Посмотреть, какие возможности поддерживаются в разных браузерах и других движках, можно в следующих источниках:

// http://caniuse.com – таблицы с информацией о поддержке по каждой возможности языка. Например, чтобы узнать, какие движки поддерживают современные криптографические функции, посетите: http://caniuse.com/#feat=cryptography.
// https://kangax.github.io/compat-table – таблица с возможностями языка и движками, которые их поддерживают и не поддерживают.


// «use strict»
// Директива выглядит как строка: "use strict" или 'use strict'. Когда она находится в начале скрипта, весь сценарий работает в «современном» режиме
// Убедитесь, что «use strict» находится в начале
// Проверьте, что "use strict" находится в первой исполняемой строке скрипта, иначе строгий режим может не включиться.

// Нет никакого способа отменить use strict
// Нет директивы типа "no use strict", которая возвращала бы движок к старому поведению.

// Как только мы входим в строгий режим, отменить это невозможно.
// Кто-то посоветует начинать каждый скрипт с "use strict"… Но есть способ покруче.

// Современный JavaScript поддерживает «классы» и «модули» — продвинутые структуры языка (и мы, конечно, до них доберёмся), которые автоматически включают строгий режим. Поэтому в них нет нужды добавлять директиву "use strict".

// Подытожим: пока очень желательно добавлять "use strict"; в начале ваших скриптов. Позже, когда весь ваш код будет состоять из классов и модулей, директиву можно будет опускать.




// PLUGIN -->  ease less, auto close tag, auto rename tag, auto complete tag, beautify, code runner, GitLens, Import Cost, JavaScript code snippets, live Server  
// Multiple clipboards for VSCode, Path Autocomplete, Reactjs code snippets, vscode icons, jshint, eslint

// jsHint --> npm install -g jshint

// Переменная – это «именованное хранилище» для данных. Мы можем использовать переменные для хранения товаров, посетителей и других данных.

// Для создания переменной в JavaScript используйте ключевое слово let.
// Приведённая ниже инструкция создаёт (другими словами: объявляет или определяет) переменную с именем «message»:
// let message;

// // Теперь можно поместить в неё данные, используя оператор присваивания = 
// let message;
// message = 'Hello';
// console.log(message);


// var leftBorder = 2;
// let second = 5;
// const pi = 3.14;

// console.log(leftBorder); 
// console.log(second);
// // console.log(pi);

// Мы также можем объявить несколько переменных в одной строке:

// let user = 'John', age = 25, message = 'Hello';
// Такой способ может показаться короче, но мы не рекомендуем его. Для лучшей читаемости объявляйте каждую переменную на новой строке.

// Многострочный вариант немного длиннее, но легче для чтения:

// Мы также можем изменить его столько раз, сколько захотим:

// let message;

// message = 'Hello!';

// message = 'World!'; // значение изменено

// alert(message);
// При изменении значения старые данные удаляются из переменной:

// Мы также можем объявить две переменные и скопировать данные из одной в другую.
// let hello = 'hello world';
// let message;

// message = hello;

// console.log(hello);
// console.log(message);

// Повторное объявление вызывает ошибку
// Переменная может быть объявлена только один раз.

// Повторное объявление той же переменной является ошибкой:

// Функциональные языки программирования
// Примечательно, что существуют функциональные языки программирования, такие как Scala или Erlang, которые запрещают изменять значение переменной.

// В таких языках однажды сохранённое «в коробку» значение остаётся там навсегда. Если нам нужно сохранить что-то другое, язык заставляет нас создать новую коробку (объявить новую переменную). Мы не можем использовать старую переменную.

// Хотя на первый взгляд это может показаться немного странным, эти языки вполне подходят для серьёзной разработки. Более того, есть такая область, как параллельные вычисления, где это ограничение даёт определённые преимущества. Изучение такого языка (даже если вы не планируете использовать его в ближайшее время) рекомендуется для расширения кругозора.

// Имена переменных
// В JavaScript есть два ограничения, касающиеся имён переменных:

// Имя переменной должно содержать только буквы, цифры или символы $ и _.
// Первый символ не должен быть цифрой.
// Если имя содержит несколько слов, обычно используется верблюжья нотация, то есть, слова следуют одно за другим, где каждое следующее слово начинается с заглавной буквы: myVeryLongName.

// Самое интересное – знак доллара '$' и подчёркивание '_' также можно использовать в названиях. Это обычные символы, как и буквы, без какого-либо особого значения.
// Нелатинские буквы разрешены, но не рекомендуются
// Можно использовать любой язык, включая кириллицу или даже иероглифы, например:

// Существует список зарезервированных слов, которые нельзя использовать в качестве имён переменных, потому что они используются самим языком.

// Например: let, class, return и function зарезервированы.

// Приведённый ниже код даёт синтаксическую ошибку:
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Lexical_grammar#%D0%9A%D0%BB%D1%8E%D1%87%D0%B5%D0%B2%D1%8B%D0%B5_%D1%81%D0%BB%D0%BE%D0%B2%D0%B0


// Обычно нам нужно определить переменную перед её использованием. Но в старые времена было технически возможно создать переменную простым присвоением значения без использования let. Это все ещё работает, если мы не включаем use strict в наших файлах, чтобы обеспечить совместимость со старыми скриптами.
// // заметка: "use strict" в этом примере не используется

// num = 5; // если переменная "num" раньше не существовала, она создаётся

// alert(num); // 5
// Это плохая практика, которая приводит к ошибке в строгом режиме:

// "use strict";


// Константы
// Чтобы объявить константную, то есть, неизменяемую переменную, используйте const вместо let:

// const myBirthday = '18.04.1982';
// Переменные, объявленные с помощью const, называются «константами». Их нельзя изменить. Попытка сделать это приведёт к ошибке:

// const myBirthday = '18.04.1982';

// myBirthday = '01.01.2001'; // ошибка, константу нельзя перезаписать!
// Если программист уверен, что переменная никогда не будет меняться, он может гарантировать это и наглядно донести до каждого, объявив её через const.


// Константы в верхнем регистре
// Широко распространена практика использования констант в качестве псевдонимов для трудно запоминаемых значений, которые известны до начала исполнения скрипта.

// Названия таких констант пишутся с использованием заглавных букв и подчёркивания.

// Например, сделаем константы для различных цветов в «шестнадцатеричном формате»:

// const COLOR_RED = "#F00";
// const COLOR_GREEN = "#0F0";
// const COLOR_BLUE = "#00F";
// const COLOR_ORANGE = "#FF7F00";

// // ...когда нам нужно выбрать цвет
// let color = COLOR_ORANGE;
// alert(color); // #FF7F00
// Преимущества:

// COLOR_ORANGE гораздо легче запомнить, чем "#FF7F00".
// Гораздо легче допустить ошибку при вводе "#FF7F00", чем при вводе COLOR_ORANGE.
// При чтении кода COLOR_ORANGE намного понятнее, чем #FF7F00.
// Когда мы должны использовать для констант заглавные буквы, а когда называть их нормально? Давайте разберёмся и с этим.

// Название «константа» просто означает, что значение переменной никогда не меняется. Но есть константы, которые известны до выполнения (например, шестнадцатеричное значение для красного цвета), а есть константы, которые вычисляются во время выполнения сценария, но не изменяются после их первоначального назначения.

// Например:

// const pageLoadTime = /* время, потраченное на загрузку веб-страницы */;
// Значение pageLoadTime неизвестно до загрузки страницы, поэтому её имя записано обычными, а не прописными буквами. Но это всё ещё константа, потому что она не изменяется после назначения.

// Другими словами, константы с именами, записанными заглавными буквами, используются только как псевдонимы для «жёстко закодированных» значений.


// Название переменной должно иметь ясный и понятный смысл, говорить о том, какие данные в ней хранятся.

// Именование переменных – это один из самых важных и сложных навыков в программировании. Быстрый взгляд на имена переменных может показать, какой код был написан новичком, а какой – опытным разработчиком.

// В реальном проекте большая часть времени тратится на изменение и расширение существующей кодовой базы, а не на написание чего-то совершенно нового с нуля. Когда мы возвращаемся к коду после какого-то промежутка времени, гораздо легче найти информацию, которая хорошо размечена. Или, другими словами, когда переменные имеют хорошие имена.
// Несколько хороших правил:

// Используйте легко читаемые имена, такие как userName или shoppingCart.
// Избегайте использования аббревиатур или коротких имён, таких как a, b, c, за исключением тех случаев, когда вы точно знаете, что так нужно.
// Делайте имена максимально описательными и лаконичными. Примеры плохих имён: data и value. Такие имена ничего не говорят. Их можно использовать только в том случае, если из контекста кода очевидно, какие данные хранит переменная.
// Договоритесь с вашей командой об используемых терминах. Если посетитель сайта называется «user», тогда мы должны называть связанные с ним переменные currentUser или newUser, а не, к примеру, currentVisitor или newManInTown.


// Повторно использовать или создавать новую переменную?
// И последняя заметка. Есть ленивые программисты, которые вместо объявления новых переменных повторно используют существующие.

// В результате их переменные похожи на коробки, в которые люди бросают разные предметы, не меняя на них этикетки. Что сейчас находится внутри коробки? Кто знает? Нам необходимо подойти поближе и проверить.

// Такие программисты немного экономят на объявлении переменных, но теряют в десять раз больше при отладке.

// Дополнительная переменная – это добро, а не зло.

// Современные JavaScript-минификаторы и браузеры оптимизируют код достаточно хорошо, поэтому он не создаёт проблем с производительностью. Использование разных переменных для разных значений может даже помочь движку оптимизировать ваш код.

// Итого
// Мы можем объявить переменные для хранения данных с помощью ключевых слов var, let или const.

// let – это современный способ объявления.
// var – это устаревший способ объявления. Обычно мы вообще не используем его, но мы рассмотрим тонкие отличия от let в главе Устаревшее ключевое слово "var" на случай, если это всё-таки вам понадобится.
// const – похоже на let, но значение переменной не может изменяться.
// Переменные должны быть названы таким образом, чтобы мы могли легко понять, что у них внутри.



// Типы данных
// Значение в JavaScript всегда относится к данным определённого типа. Например, это может быть строка или число.

// Есть восемь основных типов данных в JavaScript. В этой главе мы рассмотрим их в общем, а в следующих главах поговорим подробнее о каждом.

// Переменная в JavaScript может содержать любые данные. В один момент там может быть строка, а в другой – число:

// // Не будет ошибкой
// let message = "hello";
// message = 123456;
// Языки программирования, в которых такое возможно, называются «динамически типизированными». Это значит, что типы данных есть, но переменные не привязаны ни к одному из них.

// Число
// let n = 123;
// n = 12.345;
// Числовой тип данных (number) представляет как целочисленные значения, так и числа с плавающей точкой.

// Существует множество операций для чисел, например, умножение *, деление /, сложение +, вычитание - и так далее.

// Кроме обычных чисел, существуют так называемые «специальные числовые значения», которые относятся к этому типу данных: Infinity, -Infinity и NaN.

// Infinity представляет собой математическую бесконечность ∞. Это особое значение, которое больше любого числа.

// Мы можем получить его в результате деления на ноль:

// alert( 1 / 0 ); // Infinity
// Или задать его явно:

// alert( Infinity ); // Infinity
// NaN означает вычислительную ошибку. Это результат неправильной или неопределённой математической операции, например:

// alert( "не число" / 2 ); // NaN, такое деление является ошибкой
// Значение NaN «прилипчиво». Любая операция с NaN возвращает NaN:

// alert( "не число" / 2 + 5 ); // NaN
// Если где-то в математическом выражении есть NaN, то результатом вычислений с его участием будет NaN.

// Математические операции – безопасны
// Математические операции в JavaScript «безопасны». Мы можем делать что угодно: делить на ноль, обращаться с нечисловыми строками как с числами и т.д.

// Скрипт никогда не остановится с фатальной ошибкой (не «умрёт»). В худшем случае мы получим NaN как результат выполнения.

// Специальные числовые значения относятся к типу «число». Конечно, это не числа в привычном значении этого слова.

// BigInt
// В JavaScript тип «number» не может содержать числа больше, чем (253-1) (т. е. 9007199254740991), или меньше, чем -(253-1) для отрицательных чисел. Это техническое ограничение вызвано их внутренним представлением.

// Для большинства случаев этого достаточно. Но иногда нам нужны действительно гигантские числа, например, в криптографии или при использовании метки времени («timestamp») с микросекундами.

// Тип BigInt был добавлен в JavaScript, чтобы дать возможность работать с целыми числами произвольной длины.
// // символ "n" в конце означает, что это BigInt
// const bigInt = 1234567890123456789012345678901234567890n;

// Строка
// Строка (string) в JavaScript должна быть заключена в кавычки.

// let str = "Привет";
// let str2 = 'Одинарные кавычки тоже подойдут';
// let phrase = `Обратные кавычки позволяют встраивать переменные ${str}`;
// В JavaScript существует три типа кавычек.

// Двойные кавычки: "Привет".
// Одинарные кавычки: 'Привет'.
// Обратные кавычки: `Привет`.
// Двойные или одинарные кавычки являются «простыми», между ними нет разницы в JavaScript.

// Обратные же кавычки имеют расширенную функциональность. Они позволяют нам встраивать выражения в строку, заключая их в ${…}. Например:

// let name = "Иван";

// // Вставим переменную
// alert( `Привет, ${name}!` ); // Привет, Иван!

// // Вставим выражение
// alert( `результат: ${1 + 2}` ); // результат: 3
// Выражение внутри ${…} вычисляется, и его результат становится частью строки. Мы можем положить туда всё, что угодно: переменную name, или выражение 1 + 2, или что-то более сложное.

// Обратите внимание, что это можно делать только в обратных кавычках. Другие кавычки не имеют такой функциональности встраивания!

// alert( "результат: ${1 + 2}" ); // результат: ${1 + 2} (двойные кавычки ничего не делают)
// Мы рассмотрим строки более подробно в главе Строки.

// Нет отдельного типа данных для одного символа.
// В некоторых языках, например C и Java, для хранения одного символа, например "a" или "%", существует отдельный тип. В языках C и Java это char.

// В JavaScript подобного типа нет, есть только тип string. Строка может содержать ноль символов (быть пустой), один символ или множество.

// let name = 'viktor';
// console.log(`Hello:, ${name}!`);
// console.log(`hello: ${1 + 2}`);


// Булевый (логический) тип
// Булевый тип (boolean) может принимать только два значения: true (истина) и false (ложь).

// Такой тип, как правило, используется для хранения значений да/нет: true значит «да, правильно», а false значит «нет, не правильно».

// let isGreater = 4 > 1;
// console.log(isGreater);

// Значение «null»
// Специальное значение null не относится ни к одному из типов, описанных выше.

// Оно формирует отдельный тип, который содержит только значение null:

// let age = null;
// В JavaScript null не является «ссылкой на несуществующий объект» или «нулевым указателем», как в некоторых других языках.

// Это просто специальное значение, которое представляет собой «ничего», «пусто» или «значение неизвестно».

// В приведённом выше коде указано, что значение переменной age неизвестно.

// let age = null;
// console.log(age);


// Значение «undefined»
// Специальное значение undefined также стоит особняком. Оно формирует тип из самого себя так же, как и null.

// Оно означает, что «значение не было присвоено».

// Если переменная объявлена, но ей не присвоено никакого значения, то её значением будет undefined:

// let age;

// alert(age); // выведет "undefined"
// Технически мы можем присвоить значение undefined любой переменной:

// let age = 123;

// // изменяем значение на undefined
// age = undefined;

// alert(age); // "undefined"
// …Но так делать не рекомендуется. Обычно null используется для присвоения переменной «пустого» или «неизвестного» значения, а undefined – для проверок, была ли переменная назначена.

// let age = 34;
// age = undefined;
// console.log(age);


// Объекты и символы
// Тип object (объект) – особенный.

// Все остальные типы называются «примитивными», потому что их значениями могут быть только простые значения (будь то строка, или число, или что-то ещё). В объектах же хранят коллекции данных или более сложные структуры.

// Объекты занимают важное место в языке и требуют особого внимания. Мы разберёмся с ними в главе Объекты после того, как узнаем больше о примитивах.

// Тип symbol (символ) используется для создания уникальных идентификаторов в объектах. Мы упоминаем здесь о нём для полноты картины, изучим этот тип после объектов.




// Оператор typeof
// Оператор typeof возвращает тип аргумента. Это полезно, когда мы хотим обрабатывать значения различных типов по-разному или просто хотим сделать проверку.

// У него есть две синтаксические формы:

// Синтаксис оператора: typeof x.
// Синтаксис функции: typeof(x).
// Другими словами, он работает со скобками или без скобок. Результат одинаковый.

// Вызов typeof x возвращает строку с именем типа:
// typeof undefined // "undefined"

// typeof 0 // "number"

// typeof 10n // "bigint"

// typeof true // "boolean"

// typeof "foo" // "string"

// typeof Symbol("id") // "symbol"

// typeof Math // "object"  (1)

// typeof null // "object"  (2)

// typeof alert // "function"  (3)

// console.log(undefined);
// console.log(0);
// console.log(10n);
// console.log(true);
// console.log('foo');
// console.log(Symbol);
// console.log(Math);
// console.log(null);
// console.log(alert);

// Последние три строки нуждаются в пояснении:

// Math — это встроенный объект, который предоставляет математические операции и константы. Мы рассмотрим его подробнее в главе Числа. Здесь он служит лишь примером объекта.
// Результатом вызова typeof null является "object". Это официально признанная ошибка в typeof, ведущая начало с времён создания JavaScript и сохранённая для совместимости. Конечно, null не является объектом. Это специальное значение с отдельным типом.
// Вызов typeof alert возвращает "function", потому что alert является функцией. Мы изучим функции в следующих главах, где заодно увидим, что в JavaScript нет специального типа «функция». Функции относятся к объектному типу. Но typeof обрабатывает их особым образом, возвращая "function". Так тоже повелось от создания JavaScript. Формально это неверно, но может быть удобным на практике.
// Итого
// В JavaScript есть 8 основных типов.

// number для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном ±(253-1).
// bigint для целых чисел произвольной длины.
// string для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
// boolean для true/false.
// null для неизвестных значений – отдельный тип, имеющий одно значение null.
// undefined для неприсвоенных значений – отдельный тип, имеющий одно значение undefined.
// object для более сложных структур данных.
// symbol для уникальных идентификаторов.
// Оператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной.

// Имеет две формы: typeof x или typeof(x).
// Возвращает строку с именем типа. Например, "string".
// Для null возвращается "object" – это ошибка в языке, на самом деле это не объект.
// В следующих главах мы сконцентрируемся на примитивных значениях, а когда познакомимся с ними, перейдём к объектам.


// Взаимодействие: alert, prompt, confirm
// Так как мы будем использовать браузер как демо-среду, нам нужно познакомиться с несколькими функциями его интерфейса, а именно: alert, prompt и confirm.

// alert
// Это небольшое окно с сообщением называется модальным окном. Понятие модальное означает, что пользователь не может взаимодействовать с интерфейсом остальной части страницы, нажимать на другие кнопки и т.д. до тех пор, пока взаимодействует с окном. В данном случае – пока не будет нажата кнопка «OK».

// prompt
// Функция prompt принимает два аргумента:

// result = prompt(title, [default]);
// Этот код отобразит модальное окно с текстом, полем для ввода текста и кнопками OK/Отмена.

// title
// Текст для отображения в окне.
// default
// Необязательный второй параметр, который устанавливает начальное значение в поле для текста в окне.
// Квадратные скобки в синтаксисе [...]
// Квадратные скобки вокруг default в описанном выше синтаксисе означают, что параметр факультативный, необязательный.


// Пользователь может напечатать что-либо в поле ввода и нажать OK. Введённый текст будет присвоен переменной result. Пользователь также может отменить ввод нажатием на кнопку «Отмена» или нажав на клавишу Esc. В этом случае значением result станет null.

// Вызов prompt возвращает текст, указанный в поле для ввода, или null, если ввод отменён пользователем.


// let age = prompt('How you age?', 100);
// alert(`You ${age} year!`);

// confirm
// Синтаксис:

// result = confirm(question);
// Функция confirm отображает модальное окно с текстом вопроса question и двумя кнопками: OK и Отмена.

// Результат – true, если нажата кнопка OK. В других случаях – false.

// let isBoss = confirm("Are you here?");
// // alert( isBoss );
// console.log(isBoss);

// Итого
// Мы рассмотрели 3 функции браузера для взаимодействия с пользователем:

// alert
// показывает сообщение.
// prompt
// показывает сообщение и запрашивает ввод текста от пользователя. Возвращает напечатанный в поле ввода текст или null, если была нажата кнопка «Отмена» или Esc с клавиатуры.
// confirm
// показывает сообщение и ждёт, пока пользователь нажмёт OK или Отмена. Возвращает true, если нажата OK, и false, если нажата кнопка «Отмена» или Esc с клавиатуры.
// Все эти методы являются модальными: останавливают выполнение скриптов и не позволяют пользователю взаимодействовать с остальной частью страницы до тех пор, пока окно не будет закрыто.

// На все указанные методы распространяются два ограничения:

// Расположение окон определяется браузером. Обычно окна находятся в центре.
// Визуальное отображение окон зависит от браузера, и мы не можем изменить их вид.
// Такова цена простоты. Есть другие способы показать более приятные глазу окна с богатой функциональностью для взаимодействия с пользователем, но если «навороты» не имеют значения, то данные методы работают отлично.



// Преобразование типов
// Чаще всего операторы и функции автоматически приводят переданные им значения к нужному типу.

// Например, alert автоматически преобразует любое значение к строке. Математические операторы преобразуют значения к числам.

// Есть также случаи, когда нам нужно явно преобразовать значение в ожидаемый тип.

// Строковое преобразование
// Строковое преобразование происходит, когда требуется представление чего-либо в виде строки.

// Например, alert(value) преобразует значение к строке.

// Также мы можем использовать функцию String(value), чтобы преобразовать значение к строке:

// let value = true;
// console.log(typeof value);

// value = String(value);
// console.log(typeof value);



// Численное преобразование
// Численное преобразование происходит в математических функциях и выражениях.

// Например, когда операция деления / применяется не к числу:
// let mes = ("5" / "2");
// console.log(mes);

// let numberOne = "12345";
// console.log(typeof numberOne);

// let numberDoubleOne = Number(numberOne);
// console.log(typeof numberDoubleOne)

// Явное преобразование часто применяется, когда мы ожидаем получить число из строкового контекста, например из текстовых полей форм


// Если строка не может быть явно приведена к числу, то результатом преобразования будет NaN.
// let age = Number("Anything string without number");
// console.log(age);


// Значение	Преобразуется в…
// undefined	NaN
// null	0
// true / false	1 / 0
// string	Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN.


// console.log(Number(" 3345 "));
// console.log(Number("123z"));
// console.log(Number(true));
// console.log(Number(false));


// Логическое преобразование
// Логическое преобразование самое простое.

// Происходит в логических операциях (позже мы познакомимся с условными проверками и подобными конструкциями), но также может быть выполнено явно с помощью функции Boolean(value).

// Правило преобразования:

// Значения, которые интуитивно «пустые», вроде 0, пустой строки, null, undefined и NaN, становятся false.
// Все остальные значения становятся true

// console.log(Boolean(0));
// console.log(Boolean(1));

// console.log(Boolean("hy"));
// console.log(Boolean(456));

// console.log(Boolean(""));
// console.log(Boolean(null));
// console.log(Boolean(NaN));

// console.log("-----------------------------");


// Итого
// Существует 3 наиболее широко используемых преобразования: строковое, численное и логическое.

// Строковое – Происходит, когда нам нужно что-то вывести. Может быть вызвано с помощью String(value). Для примитивных значений работает очевидным образом.

// Численное – Происходит в математических операциях. Может быть вызвано с помощью Number(value).

// Преобразование подчиняется правилам:

// Значение	Становится…
// undefined	NaN
// null	0
// true / false	1 / 0
// string	Пробельные символы по краям обрезаются. Далее, если остаётся пустая строка, то получаем 0, иначе из непустой строки «считывается» число. При ошибке результат NaN.
// Логическое – Происходит в логических операциях. Может быть вызвано с помощью Boolean(value).

// Подчиняется правилам:

// Значение	Становится…
// 0, null, undefined, NaN, ""	false
// любое другое значение	true
// Большую часть из этих правил легко понять и запомнить. Особые случаи, в которых часто допускаются ошибки:

// undefined при численном преобразовании становится NaN, не 0.
// "0" и строки из одних пробелов типа " " при логическом преобразовании всегда true.







// Термины: «унарный», «бинарный», «операнд»
// Прежде, чем мы двинемся дальше, давайте разберёмся с терминологией.

// Операнд – то, к чему применяется оператор. Например, в умножении 5 * 2 есть два операнда: левый операнд равен 5, а правый операнд равен 2. Иногда их называют «аргументами» вместо «операндов».

// Унарным называется оператор, который применяется к одному операнду. Например, оператор унарный минус "-" меняет знак числа на противоположный:

// Математика
// Поддерживаются следующие математические операторы:

// Сложение +,
// Вычитание -,
// Умножение *,
// Деление /,
// Взятие остатка от деления %,
// Возведение в степень **.
// Первые четыре оператора очевидны, а про % и ** стоит сказать несколько слов.

// Взятие остатка %
// Оператор взятия остатка %, несмотря на обозначение, никакого отношения к процентам не имеет.

// Результат a % b – это остаток от целочисленного деления a на b.

// console.log( 5 % 2);
// console.log( 10 % 3);
// console.log( 8 % 3);

// Возведение в степень **
// В выражении a ** b оператор возведения в степень умножает a на само себя b раз.

// alert( 2 ** 2 ); // 4  (2 умножено на себя 2 раза)
// alert( 2 ** 3 ); // 8  (2 * 2 * 2, 3 раза)
// alert( 2 ** 4 ); // 16 (2 * 2 * 2 * 2, 4 раза)

// Математически, оператор работает и для нецелых чисел. Например, квадратный корень является возведением в степень 1/2:

// alert( 4 ** (1/2) ); // 2 (степень 1/2 эквивалентна взятию квадратного корня)
// alert( 8 ** (1/3) ); // 2 (степень 1/3 эквивалентна взятию кубического корня)

// Сложение строк при помощи бинарного +
// Давайте рассмотрим специальные возможности операторов JavaScript, которые выходят за рамки школьной арифметики.

// Обычно при помощи плюса '+' складывают числа.

// Но если бинарный оператор '+' применить к строкам, то он их объединяет в одну

// let s = "My" + " dream";
// console.log(s);

// Обратите внимание, если хотя бы один операнд является строкой, то второй будет также преобразован в строку.

// let s = '1' + 2;
// console.log(typeof s); //string
// console.log(Number(s));

// let s1 = 2 + 2 + '1'; 
// console.log(s1); 41

// Сложение и преобразование строк — это особенность бинарного плюса +. Другие арифметические операторы работают только с числами и всегда преобразуют операнды в числа.
// console.log('4' - 22);

// Плюс + существует в двух формах: бинарной, которую мы использовали выше, и унарной.

// Унарный, то есть применённый к одному значению, плюс + ничего не делает с числами. Но если операнд не число, унарный плюс преобразует его в число.
// let x = 1;
// console.log( +x );

// let y = 2;
// console.log( +y );

// console.log( +true );
// console.log( +"" );
// let str = +'45';
// console.log(typeof str);
// На самом деле это то же самое, что и Number(...), только короче.

// Необходимость преобразовывать строки в числа возникает очень часто. Например, обычно значения полей HTML-формы — это строки. А что, если их нужно, к примеру, сложить?

// Бинарный плюс сложит их как строки:
// let apples = "2";
// let oranges = "6";
// let doubleFruit = apples + oranges; 

// console.log( typeof doubleFruit);
// let research = Number(doubleFruit);
// console.log(research);
// console.log(typeof research);


// let apples = '2',
//     oranges = '6';

//     console.log( +apples + +oranges);
//     console.log(typeof +apples);
//     С точки зрения математика, такое изобилие плюсов выглядит странным. Но с точки зрения программиста тут нет ничего особенного: сначала выполнятся унарные плюсы, которые приведут строки к числам, а затем бинарный '+' их сложит.

//     console.log( Number(apples) + Number(oranges) );

// Приоритет операторов
// В том случае, если в выражении есть несколько операторов – порядок их выполнения определяется приоритетом, или, другими словами, существует определённый порядок выполнения операторов.
// В JavaScript много операторов. Каждый оператор имеет соответствующий номер приоритета. Тот, у кого это число больше, – выполнится раньше. Если приоритет одинаковый, то порядок выполнения – слева направо.
// https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Operators/Operator_Precedence

// Присваивание
// Давайте отметим, что в таблице приоритетов также есть оператор присваивания =. У него один из самых низких приоритетов: 3.

// Именно поэтому, когда переменной что-либо присваивают, например, x = 2 * 2 + 1, то сначала выполнится арифметика, а уже затем произойдёт присваивание = с сохранением результата в x.
// Большинство операторов в JavaScript возвращают значение. Для некоторых это очевидно, например сложение + или умножение *. Но и оператор присваивания не является исключением.

// Вызов x = value записывает value в x и возвращает его.

// Благодаря этому присваивание можно использовать как часть более сложного выражения:

// let a = 1;
// let b = 2;

// let c = 3 - (a = b + 1);

// alert( a ); // 3
// alert( c ); // 0
// В примере выше результатом (a = b + 1) будет значение, которое присваивается переменной a (то есть 3). Потом оно используется для дальнейших вычислений.




// Присваивание по цепочке
// Рассмотрим ещё одну интересную возможность: цепочку присваиваний.

// let a, b, c;

// a = b = c = 2 + 2;

// alert( a ); // 4
// alert( b ); // 4
// alert( c ); // 4

// Такое присваивание работает справа налево. Сначала вычисляется самое правое выражение 2 + 2, и затем результат присваивается переменным слева: c, b и a. В конце у всех переменных будет одно значение.

// Опять-таки, чтобы код читался легче, лучше разделять подобные конструкции на несколько строчек:

// c = 2 + 2;
// b = c;
// a = c;
// Польза от такого стиля особенно ощущается при быстром просмотре кода.



// Сокращённая арифметика с присваиванием
// let n = 2;
// n = n + 5;
// n = n * 2;
// Эту запись можно укоротить при помощи совмещённых операторов += и *=:

// let n = 2;
// n += 5; // теперь n = 7 (работает как n = n + 5)
// n *= 2; // теперь n = 14 (работает как n = n * 2)

// alert( n ); // 14
// Подобные краткие формы записи существуют для всех арифметических и побитовых операторов: /=, -= и так далее.


// Вызов с присваиванием имеет в точности такой же приоритет, как обычное присваивание, то есть выполнится после большинства других операций:

// let n = 2;

// n *= 3 + 5;

// alert( n ); // 16  (сначала выполнится правая часть, выражение идентично n *= 8)

// Инкремент/декремент
// Одной из наиболее частых числовых операций является увеличение или уменьшение на единицу.

// Для этого существуют даже специальные операторы:

// Инкремент ++ увеличивает переменную на 1:

// let counter = 2;
// counter++;        // работает как counter = counter + 1, просто запись короче
// alert( counter ); // 3

// Декремент -- уменьшает переменную на 1:

// let counter = 2;
// counter--;        // работает как counter = counter - 1, просто запись короче
// // alert( counter ); // 1


// Важно:
// Инкремент/декремент можно применить только к переменной. Попытка использовать его на значении, типа 5++, приведёт к ошибке
// Операторы ++ и -- могут быть расположены не только после, но и до переменной.

// Когда оператор идёт после переменной — это «постфиксная форма»: counter++.
// «Префиксная форма» — это когда оператор идёт перед переменной: ++counter.
// Давайте проясним этот момент. Как мы знаем, все операторы возвращают значение. Операторы инкремента/декремента не исключение. Префиксная форма возвращает новое значение, в то время как постфиксная форма возвращает старое (до увеличения/уменьшения числа).

// //Префиксная
// let count = 1;
// let counter = ++count;
// console.log(counter);

// //Постфиксная
// let countTwo = 1;
// let counterTwo = ++countTwo + 2;
// console.log(counterTwo);
// В строке (*) постфиксная форма counter++ также увеличивает counter, но возвращает старое значение (которое было до увеличения). Так что alert покажет 1. Если провести операцию тогда
// counterTwo изменится

// let counter = 0;
// counter++;
// ++counter;
// console.log(counter);//2


// Инкремент/декремент можно использовать в любых выражениях
// Операторы ++/-- могут также использоваться внутри выражений. Их приоритет выше, чем у большинства других арифметических операций.
// let counter = 1;
// alert( 2 * counter++ ); // 2, потому что counter++ возвращает "старое" значение

// Лучше использовать стиль «одна строка – одно действие»:

// let counter = 1;
// counter++
// console.log(2 * counter ); //4
// counter++;
// console.log(counter);//3



// Побитовые операторы
// Побитовые операторы работают с 32-разрядными целыми числами (при необходимости приводят к ним), на уровне их внутреннего двоичного представления.

// Эти операторы не являются чем-то специфичным для JavaScript, они поддерживаются в большинстве языков программирования.

// Поддерживаются следующие побитовые операторы:

// AND(и) ( & )
// OR(или) ( | )
// XOR(побитовое исключающее или) ( ^ )
// NOT(не) ( ~ )
// LEFT SHIFT(левый сдвиг) ( << )
// RIGHT SHIFT(правый сдвиг) ( >> )
// ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) ( >>> )
// Они используются редко, когда возникает необходимость оперировать с числами на очень низком (побитовом) уровне. В ближайшем времени они нам не понадобятся, так как веб-разработчики редко к ним прибегают, хотя в некоторых сферах (например, в криптографии) они полезны. Можете прочитать раздел о них на MDN, когда возникнет реальная необходимость.

// Оператор «запятая»
// Оператор «запятая» предоставляет нам возможность вычислять несколько выражений, разделяя их запятой ,. Каждое выражение выполняется, но возвращается результат только последнего.

// let a = (1 + 2, 3 + 4);
// alert( a ); // 7 (результат вычисления 3 + 4)


// Запятая имеет очень низкий приоритет
// Пожалуйста, обратите внимание, что оператор , имеет очень низкий приоритет, ниже =, поэтому скобки важны в приведённом выше примере.

// Без них в a = 1 + 2, 3 + 4 сначала выполнится +, суммируя числа в a = 3, 7, затем оператор присваивания = присвоит a = 3, а то, что идёт дальше, будет игнорировано. Всё так же, как в (a = 1 + 2), 3 + 4.
// Зачем нам оператор, который отбрасывает всё, кроме последнего выражения?

// Иногда его используют в составе более сложных конструкций, чтобы сделать несколько действий в одной строке.

// Например:

// // три операции в одной строке
// for (a = 1, b = 3, c = a * b; a < 10; a++) {
//  ...
// }



// console.log(2 > 1);
// console.log(2 == 2);
// console.log( 2 != 1);
// let result = 5 != 4;
// console.log(result);


// Сравнение строк
// Чтобы определить, что одна строка больше другой, JavaScript использует «алфавитный» или «лексикографический» порядок.

// Результат сравнения имеет логический тип
// Все операторы сравнения возвращают значение логического типа:

// true – означает «да», «верно», «истина».
// false – означает «нет», «неверно», «ложь».
// Алгоритм сравнения двух строк довольно прост:

// Сначала сравниваются первые символы строк.
// Если первый символ первой строки больше (меньше), чем первый символ второй, то первая строка больше (меньше) второй. Сравнение завершено.
// Если первые символы равны, то таким же образом сравниваются уже вторые символы строк.
// Сравнение продолжается, пока не закончится одна из строк.
// Если обе строки заканчиваются одновременно, то они равны. Иначе, большей считается более длинная строка.
// В примерах выше сравнение 'Я' > 'А' завершится на первом шаге, тогда как строки 'Коты' и 'Кода' будут сравниваться посимвольно:

// К равна К.
// о равна о.
// т больше, чем д. На этом сравнение заканчивается. Первая строка больше.

// Используется кодировка Unicode, а не настоящий алфавит
// Приведённый выше алгоритм сравнения похож на алгоритм, используемый в словарях и телефонных книгах, но между ними есть и различия.

// Например, в JavaScript имеет значение регистр символов. Заглавная буква "A" не равна строчной "a". Какая же из них больше? Строчная "a". Почему? Потому что строчные буквы имеют больший код во внутренней таблице кодирования, которую использует JavaScript (Unicode). Мы ещё поговорим о внутреннем представлении строк и его влиянии в главе Строки.


// Сравнение разных типов
// При сравнении значений разных типов JavaScript приводит каждое из них к числу.
// alert( '2' > 1 ); // true, строка '2' становится числом 2
// alert( '01' == 1 ); // true, строка '01' становится числом 1
// Логическое значение true становится 1, а false – 0.

// Например:

// alert( true == 1 ); // true
// alert( false == 0 ); // true

// let a = 0;
// alert( Boolean(a) ); // false

// let b = "0";
// alert( Boolean(b) ); // true

// alert(a == b); // true!
// С точки зрения JavaScript, результат ожидаем. Равенство преобразует значения, используя числовое преобразование, поэтому "0" становится 0. В то время как явное преобразование с помощью Boolean использует другой набор правил.


// Строгое сравнение
// Использование обычного сравнения == может вызывать проблемы. Например, оно не отличает 0 от false:

// alert( 0 == false ); // true
// Та же проблема с пустой строкой:

// alert( '' == false ); // true
// Это происходит из-за того, что операнды разных типов преобразуются оператором == к числу. В итоге, и пустая строка, и false становятся нулём.

// Как же тогда отличать 0 от false?

// Оператор строгого равенства === проверяет равенство без приведения типов.

// Другими словами, если a и b имеют разные типы, то проверка a === b немедленно возвращает false без попытки их преобразования.

// Давайте проверим:

// alert( 0 === false ); // false, так как сравниваются разные типы
// Ещё есть оператор строгого неравенства !==, аналогичный !=.

// Оператор строгого равенства дольше писать, но он делает код более очевидным и оставляет меньше места для ошибок.




// Сравнение с null и undefined
// Поведение null и undefined при сравнении с другими значениями — особое:

// При строгом равенстве ===
// Эти значения различны, так как различны их типы.

// alert( null === undefined ); // false
// При нестрогом равенстве ==
// Эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка.

// alert( null == undefined ); // true
// При использовании математических операторов и других операторов сравнения < > <= >=
// Значения null/undefined преобразуются к числам: null становится 0, а undefined – NaN.

// Посмотрим, какие забавные вещи случаются, когда мы применяем эти правила. И, что более важно, как избежать ошибок при их использовании.

// Странный результат сравнения null и 0
// Сравним null с нулём:

// alert( null > 0 );  // (1) false
// alert( null == 0 ); // (2) false
// alert( null >= 0 ); // (3) true
// С точки зрения математики это странно. Результат последнего сравнения говорит о том, что "null больше или равно нулю", тогда результат одного из сравнений выше должен быть true, но они оба ложны.

// Причина в том, что нестрогое равенство и сравнения > < >= <= работают по-разному. Сравнения преобразуют null в число, рассматривая его как 0. Поэтому выражение (3) null >= 0 истинно, а null > 0 ложно.

// С другой стороны, для нестрогого равенства == значений undefined и null действует особое правило: эти значения ни к чему не приводятся, они равны друг другу и не равны ничему другому. Поэтому (2) null == 0 ложно.

// Причина в том, что нестрогое равенство и сравнения > < >= <= работают по-разному. Сравнения преобразуют null в число, рассматривая его как 0. Поэтому выражение (3) null >= 0 истинно, а null > 0 ложно.

// С другой стороны, для нестрогого равенства == значений undefined и null действует особое правило: эти значения ни к чему не приводятся, они равны друг другу и не равны ничему другому. Поэтому (2) null == 0 ложно.




// Условное ветвление: if, '?'
// Иногда нам нужно выполнить различные действия в зависимости от условий.

// Для этого мы можем использовать инструкцию if и условный оператор ?, который также называют оператором «вопросительный знак».

// let year = prompt('How old are you?');
// if (year == 30){
//     alert('Done')
// }else{
//     alert('False')
// }


// Преобразование к логическому типу
// Инструкция if (…) вычисляет выражение в скобках и преобразует результат к логическому типу.

// Давайте вспомним правила преобразования типов из главы Преобразование типов:

// Число 0, пустая строка "", null, undefined и NaN становятся false. Из-за этого их называют «ложными» («falsy») значениями.
// Остальные значения становятся true, поэтому их называют «правдивыми» («truthy»).

// let year = prompt('How old I went in the military?');

// if (year < 2011) {
//     console.log('early');
// }else if (year > 2011) {
//     console.log('busy');
// }else {
//     console.log('Done');
// }


// let accessAllowed;
// let age = prompt('How old are you?');

// if (age > 18) {
//     accessAllowed = true;
// } else {
//     accessAllowed = false;
// }
// console.log(accessAllowed);


// Условный оператор „?“
// Оператор представлен знаком вопроса ?. Его также называют «тернарный», так как этот оператор, единственный в своём роде, имеет три аргумента.
// Синтаксис:
// let result = условие ? значение1 : значение2;
// let accessAllowed = (age > 18) ? true : false;

// let age = prompt('Age?', 18);

// let message = (age < 3) ? 'Hello hyone':
//             (age < 18) ? 'HY':
//             (age < 100) ? 'Hello':
//             'Hello kidy';

// console.log(message);


// Нетрадиционное использование „?“
// Иногда оператор «вопросительный знак» ? используется в качестве замены if:

// let company = prompt('Which company created Javascript?');
//     (company == 'Netscape') ?
//         console.log('Done!'):
//         console.log('Dis!');
// Не рекомендуется использовать оператор вопросительного знака таким образом.

// Логические операторы
// || (ИЛИ)
// Оператор «ИЛИ» выглядит как двойной символ вертикальной черты:
// alert( true || true );   // true
// alert( false || true );  // true
// alert( true || false );  // true
// alert( false || false ); // false
// Обычно оператор || используется в if для проверки истинности любого из заданных условий.

// let hour = prompt('How hours?')
// let isWeekend = true;


// if(hour < 10 || hour > 18 || isWeekend) {
//     console.log('Office closing');
// }else {
//     console.log('Office opening');
// }


// Оператор || выполняет следующие действия:

// Вычисляет операнды слева направо.
// Каждый операнд конвертирует в логическое значение. Если результат true, останавливается и возвращает исходное значение этого операнда.
// Если все операнды являются ложными (false), возвращает последний из них.

// Получение первого истинного значения из списка переменных или выражений.

// Представим, что у нас имеется ряд переменных, которые могут содержать данные или быть null/undefined. Как мы можем найти первую переменную с данными?
// let currentUser = null;
// let defaultUser = 'Viktor';

// let name = currentUser || defaultUser;
// console.log(name); // Viktor

// Сокращённое вычисление.
// // Операндами могут быть как отдельные значения, так и произвольные выражения. ИЛИ вычисляет их слева направо. Вычисление останавливается при достижении первого истинного значения. Этот процесс называется «сокращённым вычислением», поскольку второй операнд вычисляется только в том случае, если первого недостаточно для вычисления всего выражения.
// let x;
// true || (x = 1);
// console.log(x);// undefined потому что (x = 1) не вычисляется


// Как мы видим, этот вариант использования || является "аналогом if". Первый операнд преобразуется в логический. Если он оказывается ложным, начинается вычисление второго.
// В большинстве случаев лучше использовать «обычный» if, чтобы облегчить понимание кода, но иногда это может быть удобно.

// && (И)
// Оператор И пишется как два амперсанда &&:
// В традиционном программировании И возвращает true, если оба аргумента истинны, а иначе – false:
// let hour = 12;
// let minutes = 30;

// if (hour == 12 && minutes == 30) {
//     console.log(`The time is now ${hour}:${minutes}` );
// }

// Приоритет оператора && больше, чем у ||
// Приоритет оператора И && больше, чем ИЛИ ||, так что он выполняется раньше.
// Таким образом, код a && b || c && d по существу такой же, как если бы выражения && были в круглых скобках: (a && b) || (c && d).


// ! (НЕ)
// Оператор НЕ представлен восклицательным знаком !
// Оператор принимает один аргумент и выполняет следующие действия:
// Сначала приводит аргумент к логическому типу true/false.
// Затем возвращает противоположное значение.



// Приоритет НЕ ! является наивысшим из всех логических операторов, поэтому он всегда выполняется первым, перед && или ||.
// Есть немного более подробный способ сделать то же самое – встроенная функция Boolean:
// alert( Boolean("non-empty string") ); // true
// alert( Boolean(null) ); // false

// Оператор объединения с null '??'
// Эта возможность была добавлена в язык недавно. В старых браузерах может понадобиться полифил.
// Оператор объединения с null представляет собой два вопросительных знака ??.
// Результат выражения a ?? b будет следующим:
// a, если значение a определено,
// b, если значение a не определено.
// То есть оператор ?? возвращает первый аргумент, если он не null/undefined, иначе второй.
// Оператор объединения с null не является чем-то принципиально новым. Это всего лишь удобный синтаксис, как из двух значений получить одно «определённое».

// result = (a !== null && a !== undefined) ? a : b;
// let user;
// console.log(user ?? 'Anonim');
// Конечно, если бы переменная user содержала любое значение, кроме null/undefined, то мы бы увидели его:

// Кроме этого, можно записать последовательность из операторов ??, чтобы получить первое значение из списка, которое не является null/undefined
// let firstName = null;
// let secondName = null;
// let nickName = 'SuperUser';

// console.log(firstName ?? secondName ?? nickName);


// Важное различие между ними заключается в том, что:
// || возвращает первое истинное значение.
// ?? возвращает первое определённое значение.

// Однако на практике часто требуется использовать значение по умолчанию только тогда, когда переменная является null/undefined. Ведь именно тогда значение действительно неизвестно/не определено.

// let height = 0;

// console.log(height || 100);
// console.log(height ?? 100);

// Однако на практике часто требуется использовать значение по умолчанию только тогда, когда переменная является null/undefined. Ведь именно тогда значение действительно неизвестно/не определено.

// По соображениям безопасности JavaScript запрещает использование оператора ?? вместе с && и ||, если только приоритет явно не указан в круглых скобках.

// Циклы while и for
// При написании скриптов зачастую встаёт задача сделать однотипное действие много раз.
// Например, вывести товары из списка один за другим. Или просто перебрать все числа от 1 до 10 и для каждого выполнить одинаковый код.
// Для многократного повторения одного участка кода предусмотрены циклы.

// Одно выполнение тела цикла по-научному называется итерация
// Если бы строка i++ отсутствовала в примере выше, то цикл бы повторялся (в теории) вечно. На практике, конечно, браузер не позволит такому случиться, он предоставит пользователю возможность остановить «подвисший» скрипт, а JavaScript на стороне сервера придётся «убить» процесс.

// do {
//     // тело цикла
//   } while (condition);
//   Цикл сначала выполнит тело, а затем проверит условие condition, и пока его значение равно true, он будет выполняться снова и снова.

//   let i = 0;
//   do {
//     alert( i );
//     i++;
//   } while (i < 3);
//   Такая форма синтаксиса оправдана, если вы хотите, чтобы тело цикла выполнилось хотя бы один раз, даже если условие окажется ложным. На практике чаще используется форма с предусловием: while(…) {…}.


// Давайте разберёмся, что означает каждая часть, на примере. Цикл ниже выполняет alert(i) для i от 0 до (но не включая) 3:
// for (let i = 0; i <= 3; i++)
//     console.log(i);

    // начало	i = 0	Выполняется один раз при входе в цикл
    // условие	i < 3	Проверяется перед каждой итерацией цикла. Если оно вычислится в false, цикл остановится.
    // шаг	i++	Выполняется после тела цикла на каждой итерации перед проверкой условия.
    // тело	alert(i)	Выполняется снова и снова, пока условие вычисляется в true.

    // Выполнить *начало*
    // → (Если *условие* == true → Выполнить *тело*, Выполнить *шаг*)
    // → (Если *условие* == true → Выполнить *тело*, Выполнить *шаг*)
    // → (Если *условие* == true → Выполнить *тело*, Выполнить *шаг*)
    // → ...

    // То есть, начало выполняется один раз, а затем каждая итерация заключается в проверке условия, после которой выполняется тело и шаг.

    // В примере переменная счётчика i была объявлена прямо в цикле. Это так называемое «встроенное» объявление переменной. Такие переменные существуют только внутри цикла.
    // Вместо объявления новой переменной мы можем использовать уже существующую:

    // Пропуск частей «for»
    // Любая часть for может быть пропущена.
    
    // Для примера, мы можем пропустить начало если нам ничего не нужно делать перед стартом цикла.
    
    // Вот так:
    
    // let i = 0; // мы уже имеем объявленную i с присвоенным значением
    
    // for (; i < 3; i++) { // нет необходимости в "начале"
    //   alert( i ); // 0, 1, 2
    // }
    // Можно убрать и шаг:
    
    // let i = 0;
    
    // for (; i < 3;) {
    //   alert( i++ );
    // }
    // Это сделает цикл аналогичным while (i < 3).
    
    // А можно и вообще убрать всё, получив бесконечный цикл:
    
    // for (;;) {
    //   // будет выполняться вечно
    // }
    // При этом сами точки с запятой ; обязательно должны присутствовать, иначе будет ошибка синтаксиса.


//     Прерывание цикла: «break»
// Обычно цикл завершается при вычислении условия в false.

// Но мы можем выйти из цикла в любой момент с помощью специальной директивы break.

// let sum = 0;

// while(true) {
//     let value = +prompt('Enter a number', '');

//     if(!value) break;

//     sum += value;
// }
// console.log('SUM: ' + sum);

// Вообще, сочетание «бесконечный цикл + break» – отличная штука для тех ситуаций, когда условие, по которому нужно прерваться, находится не в начале или конце цикла, а посередине



// Переход к следующей итерации: continue
// Директива continue – «облегчённая версия» break. При её выполнении цикл не прерывается, а переходит к следующей итерации (если условие все ещё равно true).

// for (let i = 0; i < 10; i++) {
//     if( i % 2 == 0) {
//         console.log(i);
//     }else {
//         console.log('Fuck')
//     }
// }
// Для чётных значений i, директива continue прекращает выполнение тела цикла и передаёт управление на следующую итерацию for (со следующим числом). Таким образом alert вызывается только для нечётных значений.

// Метки для break/continue
// Бывает, нужно выйти одновременно из нескольких уровней цикла сразу

// Обычный break после input лишь прервёт внутренний цикл, но этого недостаточно. Достичь желаемого поведения можно с помощью меток.

// Метка имеет вид идентификатора с двоеточием перед циклом:

// labelName: for (...) {
//     ...
// //   }
// Вызов break <labelName> в цикле ниже ищет ближайший внешний цикл с такой меткой и переходит в его конец.
// outer: for (let i = 0; i < 3; i++) {
//     for (let j = 0; j < 3; j++) {
//         let input = prompt(`ачение на координатах(${i},${j})`, '');
//         if (!input) break outer;
//     }
// }
// console.log('Done');

// В примере выше это означает, что вызовом break outer будет разорван внешний цикл до метки с именем outer, и управление перейдёт со строки, помеченной (*), к alert('Готово!').
// Вызов break/continue возможен только внутри цикла, и метка должна находиться где-то выше этой директивы.

// Конструкция switch заменяет собой сразу несколько if.
// Она представляет собой более наглядный способ сравнить выражение сразу с несколькими вариантами.
// Конструкция switch имеет один или более блок case и необязательный блок default.
// Переменная x проверяется на строгое равенство первому значению value1, затем второму value2 и так далее.
// Если соответствие установлено – switch начинает выполняться от соответствующей директивы case и далее, до ближайшего break (или до конца switch).
// Если ни один case не совпал – выполняется (если есть) вариант default.

// let number = 2 + 2;

// switch(number) {
//     case 3:
//         console.log('Маловато');
//         brake;
//     case 6:
//         console.log('Многоватто');
//         brake;
//     case 4:
//         console.log('В точку!!');
//         brake;
//     default:
//         console.log('Нет такого значения');

//     }

    // Если break нет, то выполнение пойдёт ниже по следующим case, при этом остальные проверки игнорируются.

    // Любое выражение может быть аргументом для switch/case
    // И switch и case допускают любое выражение в качестве аргумента.

    // let numberOne = "1";
    // let numberTwo = 0;

    // switch (+numberOne) {
    //     case numberTwo + 1:
    //         console.log("Выполнится значение 1 что в точности равно numberOne + numberTwo");
    //         break;
        
    //     default:
    //         console.log("Это не выполнится");

    // }

    // В этом примере выражение +numberOne вычисляется в 1, что совпадает с выражением numberTwo + 1 в case, и следовательно, код в этом блоке будет выполнен.


    // Группировка «case»
    // Несколько вариантов case, использующих один код, можно группировать.
    // Для примера, выполним один и тот же код для case 3 и case 5, сгруппировав их:
    // let a = 2 + 2;

    // switch (a) {
    //     case 4:
    //         console.log("Правильно");
    //         break;
    //     case 3:
    //     case 6:
    //         console.log("Неправильно");
    //         console.log("Может сходить к учителю");
    //         break;    
    //     default:
    //         console.log("Странновато");
    //     }

//     Тип имеет значение
// Нужно отметить, что проверка на равенство всегда строгая. Значения должны быть одного типа, чтобы выполнялось равенство.

// let arg = prompt("Введите число: ");
// switch (arg) {
//     case '0':
//     case '1':
//         console.log("Один или Ноль");
//         break;
//     case '2':
//         console.log("Два");
//         break;
//     default:
//         console.log("Три");
// }



// Функции
// Зачастую нам надо повторять одно и то же действие во многих частях программы.
// Например, необходимо красиво вывести сообщение при приветствии посетителя, при выходе посетителя с сайта, ещё где-нибудь.
// Чтобы не повторять один и тот же код во многих местах, придуманы функции. Функции являются основными «строительными блоками» программы.
// Примеры встроенных функций вы уже видели – это alert(message), prompt(message, default) и confirm(question). Но можно создавать и свои.

// Объявление функции
// Для создания функций мы можем использовать объявление функции.
// function showMessage() {
//     alert( 'Всем привет!' );
//   }
//   Вначале идёт ключевое слово function, после него имя функции, затем список параметров в круглых скобках через запятую (в вышеприведённом примере он пустой) и, наконец, 
//   код функции, также называемый «телом функции», внутри фигурных скобок.

// function showMessage(){
//     console.log("Done This is a function!!");
// }

// showMessage();
// showMessage();

// Этот пример явно демонстрирует одно из главных предназначений функций: избавление от дублирования кода.
// Если понадобится поменять сообщение или способ его вывода – достаточно изменить его в одном месте: в функции, которая его выводит.
// Локальные переменные
// Переменные, объявленные внутри функции, видны только внутри этой функции.


// Локальные переменные
// Переменные, объявленные внутри функции, видны только внутри этой функции.
// function showMessage() {
//     let message = "Hello I am variable!"; //локальная переменная
//     console.log(message);
// }
// console.log(message);
//console.log(message); // Выведит ошибку

// Внешние переменные
// У функции есть доступ к внешним переменным,
// let userName = 'Vasy';

// function showMessage() {
//     let message = 'Hello ' + userName;
//     console.log(message);
// }
// showMessage();


// Функция обладает полным доступом к внешним переменным и может изменять их значение.
// let userName = 'Vasy';

// function showMessage() {
//     userName = 'Pety'; // заменит значения внешней переменной

//     let message = 'Hello ' + userName;
//     console.log(message);
// }
// console.log(userName);

// showMessage();

// console.log(userName);

// Внешняя переменная используется, только если внутри функции нет такой локальной.


// Если одноимённая переменная объявляется внутри функции, тогда она перекрывает внешнюю
// let userName = 'Vasy';

// function showMessage() {
//     let userName = 'Pety';

//     let message = 'hello ' + userName;
//     console.log(message);
// }

// showMessage();

// console.log(userName);


// Глобальные переменные
// Переменные, объявленные снаружи всех функций, такие как внешняя переменная userName в вышеприведённом коде – называются глобальными.

// Глобальные переменные видимы для любой функции (если только их не перекрывают одноимённые локальные переменные).

// Желательно сводить использование глобальных переменных к минимуму. В современном коде обычно мало или совсем нет глобальных переменных. Хотя они иногда полезны для хранения важнейших «общепроектовых» данных.

// Параметры
// Мы можем передать внутрь функции любую информацию, используя параметры (также называемые аргументами функции).

// function showMessage(from, text) {
//     console.log(from + ' ' + text);
// }
// showMessage('Any', 'Hello');


// function showMessage(from, text) {
//     from = '*' + from + '*';
//     console.log(from + ' ' + text);
// }

// let from = 'Nikol';

// showMessage(from, 'Hello');

// console.log(from);

// Параметры по умолчанию
// Если параметр не указан, то его значением становится undefined.
// Например, вышеупомянутая функция showMessage(from, text) может быть вызвана с одним аргументом:
// Это не приведёт к ошибке. Такой вызов выведет "Аня: undefined". В вызове не указан параметр text, поэтому предполагается, что text === undefined.
// Если мы хотим задать параметру text значение по умолчанию, мы должны указать его после =

// function showMessage(form, text="Текст не добавлен!") {
//     console.log(form + ' ' + text);
// }
// showMessage('Viktor');


// function showMessage(from, text = anotherFunction()) {
//     // anotherFunction() выполнится только если не передан text
//     // результатом будет значение text
//   }

// Вычисление параметров по умолчанию
// В JavaScript параметры по умолчанию вычисляются каждый раз, когда функция вызывается без соответствующего параметра.
// В примере выше anotherFunction() будет вызываться каждый раз, когда showMessage() вызывается без параметра text.

// Использование параметров по умолчанию в ранних версиях JavaScript
// Ранние версии JavaScript не поддерживали параметры по умолчанию. Поэтому существуют альтернативные способы, которые могут встречаться в старых скриптах.

// Например, явная проверка на undefined:

// function showMessage(from, text) {
//   if (text === undefined) {
//     text = 'текст не добавлен';
//   }

//   alert( from + ": " + text );
// }
// …Или с помощью оператора ||:

// function showMessage(from, text) {
//   // Если значение text ложно, тогда присвоить параметру text значение по умолчанию
//   text = text || 'текст не добавлен';
//   ...
// }


// Возврат значения
// Функция может вернуть результат, который будет передан в вызвавший её код.
// function sum(a, b){
//     return a + b;
 
// }
// let result = sum(1, 3);
// console.log(result);

// function checkAge(age) {
//     if (age > 18) {
//         return true;
//     } else {
//         return confirm("А родители разрешили?");
//     }
// }

// let age = prompt('Сколько тебе лет?', 18);

// if (checkAge(age)) {
//     console.log('Доступ получен');
// } else {
//     console.log('Доступ закрыт');
// }


// Результат функции с пустым return или без него – undefined
// Если функция не возвращает значения, это всё равно, как если бы она возвращала undefined:

// Результат функции с пустым return или без него – undefined
// Если функция не возвращает значения, это всё равно, как если бы она возвращала undefined:

// Никогда не добавляйте перевод строки между return и его значением
// Для длинного выражения в return может быть заманчиво разместить его на нескольких отдельных строках, например так:
// return
//  (some + long + expression + or + whatever * f(a) + f(b))
// Код не выполнится, потому что интерпретатор JavaScript подставит точку с запятой после return. Для него это будет выглядеть так:

// return;
//  (some + long + expression + or + whatever * f(a) + f(b))
// Таким образом, это фактически стало пустым return.

// Если мы хотим, чтобы возвращаемое выражение занимало несколько строк, нужно начать его на той же строке, что и return. Или, хотя бы, поставить там открывающую скобку, вот так:

// return (
//   some + long + expression
//   + or +
//   whatever * f(a) + f(b)
//   )
// И тогда всё сработает, как задумано.





// Функция – это действие. Поэтому имя функции обычно является глаголом. Оно должно быть простым, точным и описывать действие функции, чтобы программист, который будет читать код, получил верное представление о том, что делает функция.
// Например, функции, начинающиеся с "show" обычно что-то показывают.

// Функции, начинающиеся с…

// "get…" – возвращают значение,
// "calc…" – что-то вычисляют,
// "create…" – что-то создают,
// "check…" – что-то проверяют и возвращают логическое значение, и т.д.
// Примеры таких имён:

// showMessage(..)     // показывает сообщение
// getAge(..)          // возвращает возраст (в каком либо значении)
// calcSum(..)         // вычисляет сумму и возвращает результат
// createForm(..)      // создаёт форму (и обычно возвращает её)
// checkPermission(..) // проверяет доступ, возвращая true/false
// Благодаря префиксам, при первом взгляде на имя функции становится понятным что делает её код, и какое значение она может возвращать.

// Одна функция – одно действие
// Функция должна делать только то, что явно подразумевается её названием. И это должно быть одним действием.
// Два независимых действия обычно подразумевают две функции, даже если предполагается, что они будут вызываться вместе (в этом случае мы можем создать третью функцию, которая будет их вызывать).
// Несколько примеров, которые нарушают это правило:
// getAge – будет плохим выбором, если функция будет выводить alert с возрастом (должна только возвращать его).
// createForm – будет плохим выбором, если функция будет изменять документ, добавляя форму в него (должна только создавать форму и возвращать её).
// checkPermission – будет плохим выбором, если функция будет отображать сообщение с текстом доступ разрешён/запрещён (должна только выполнять проверку и возвращать её результат).
// В этих примерах использовались общепринятые смыслы префиксов. Конечно, вы в команде можете договориться о других значениях, но обычно они мало отличаются от общепринятых. В любом случае вы и ваша команда должны точно понимать, что значит префикс, что функция с ним может делать, а чего не может.


// Сверхкороткие имена функций
// Имена функций, которые используются очень часто, иногда делают сверхкороткими.

// Например, во фреймворке jQuery есть функция с именем $. В библиотеке Lodash основная функция представлена именем _.

// Это исключения. В основном имена функций должны быть в меру краткими и описательными.



// Функции должны быть короткими и делать только что-то одно. Если это что-то большое, имеет смысл разбить функцию на несколько меньших. Иногда следовать этому правилу непросто, но это определённо хорошее правило.
// Небольшие функции не только облегчают тестирование и отладку – само существование таких функций выполняет роль хороших комментариев!
// function showPrimes(n) {
//     for(let i = o; i < n; i++)
//     if(!isPrime(i)) continue;

//     console.log(i);
// }

// function isPrime(n) {
//     for(let i = 2; i < n; i++) {
//         if(n % i == 0) return false;
//     }
//     return true;
// }

// Вместо куска кода мы видим название действия (isPrime). Иногда разработчики называют такой код самодокументируемым.


// Объявление функции имеет вид:

// function имя(параметры, через, запятую) {
//   /* тело, код функции */
// // }
// Передаваемые значения копируются в параметры функции и становятся локальными переменными.
// Функции имеют доступ к внешним переменным. Но это работает только изнутри наружу. Код вне функции не имеет доступа к её локальным переменным.
// Функция может возвращать значение. Если этого не происходит, тогда результат равен undefined.
// Для того, чтобы сделать код более чистым и понятным, рекомендуется использовать локальные переменные и параметры функций, не пользоваться внешними переменными.

// Функция, которая получает параметры, работает с ними и затем возвращает результат, гораздо понятнее функции, вызываемой без параметров, но изменяющей внешние переменные, что чревато побочными эффектами.

// Именование функций:

// Имя функции должно понятно и чётко отражать, что она делает. Увидев её вызов в коде, вы должны тут же понимать, что она делает, и что возвращает.
// Функция – это действие, поэтому её имя обычно является глаголом.
// Есть много общепринятых префиксов, таких как: create…, show…, get…, check… и т.д. Пользуйтесь ими как подсказками, поясняющими, что делает функция.


// Синтаксис, который мы использовали до этого, называется Function Declaration (Объявление Функции):

// function sayHi() {
//   alert( "Привет" );
// }

// Существует ещё один синтаксис создания функций, который называется Function Expression (Функциональное Выражение).
// let sayHi = function() {
//     alert( "Привет" );
//   };
// В коде выше функция создаётся и явно присваивается переменной, как любое другое значение. По сути без разницы, как мы определили функцию, это просто значение, хранимое в переменной sayHi.

// Обратите внимание, что последняя строка не вызывает функцию sayHi, после её имени нет круглых скобок. Существуют языки программирования, в которых любое упоминание имени функции совершает её вызов. JavaScript – не один из них.

// В JavaScript функции – это значения, поэтому мы и обращаемся с ними, как со значениями. Код выше выведет строковое представление функции, которое является её исходным кодом.

// function sayHy() {
//     console.log('Hello!');
// }

// let func = sayHy;

// func();
// sayHy();

// Давайте подробно разберём всё, что тут произошло:
// Объявление Function Declaration (1) создало функцию и присвоило её значение переменной с именем sayHi.
// В строке (2) мы скопировали её значение в переменную func. Обратите внимание (ещё раз): нет круглых скобок после sayHi. Если бы они были, то выражение func = sayHi() записало бы результат вызова sayHi() в переменную func, а не саму функцию sayHi.
// Теперь функция может быть вызвана с помощью обеих переменных sayHi() и func().

// Зачем нужна точка с запятой в конце?
// У вас мог возникнуть вопрос: Почему в Function Expression ставится точка с запятой ; на конце, а в Function Declaration нет:

// function sayHi() {
//   // ...
// }

// let sayHi = function() {
//   // ...
// };
// Ответ прост:

// Нет необходимости в ; в конце блоков кода и синтаксических конструкций, которые их используют, таких как if { ... }, for { }, function f { } и т.д.
// Function Expression использует внутри себя инструкции присваивания let sayHi = ...; как значение. Это не блок кода, а выражение с присваиванием. Таким образом, точка с запятой не относится непосредственно к Function Expression, она лишь завершает инструкцию.

// function ask(question, yes, no) {
//     if (confirm(question)) yes()
//     else no();
// }

// function showOk() {
//     console.log('Done');
// }

// function showCancel() {
//     console.log('NoOK!');
// }

// ask('Are you series??', showOk, showCancel);

// На практике подобные функции очень полезны. Основное отличие «реальной» функции ask от примера выше будет в том, что она использует более сложные способы взаимодействия с пользователем, чем простой вызов confirm. В браузерах такие функции обычно отображают красивые диалоговые окна. Но это уже другая история.


// Аргументы функции ask ещё называют функциями-колбэками или просто колбэками.
// Ключевая идея в том, что мы передаём функцию и ожидаем, что она вызовется обратно (от англ. «call back» – обратный вызов) когда-нибудь позже, если это будет необходимо. 
//В нашем случае, showOk становится колбэком’ для ответа «yes», а showCancel – для ответа «no».

// Более короткий пример:
// function ask(question, yes, no) {
//     if (confirm(question)) yes()
//     else no();
// }

// ask (
//     "Are you sure??",
//     function() { console.log('DONE!!'); },
//     function() { console.log('NoOK!!'); }
// );

// Здесь функции объявляются прямо внутри вызова ask(...). У них нет имён, поэтому они называются анонимными. Такие функции недоступны снаружи ask (потому что они не присвоены переменным), но это как раз то, что нам нужно.
// Подобный код, появившийся в нашем скрипте выглядит очень естественно, в духе JavaScript.



// Функция – это значение, представляющее «действие»
// Обычные значения, такие как строки или числа представляют собой данные.

// Функции, с другой стороны, можно воспринимать как «действия».

// Мы можем передавать их из переменной в переменную и запускать, когда захотим.



// Function Expression в сравнении с Function Declaration
// Во-первых, синтаксис: как определить, что есть что в коде.

// Function Declaration: функция объявляется отдельной конструкцией «function…» в основном потоке кода.

// // Function Declaration
// function sum(a, b) {
//   return a + b;
// }
// Function Expression: функция, созданная внутри другого выражения или синтаксической конструкции. В данном случае функция создаётся в правой части «выражения присваивания» =:

// // Function Expression
// let sum = function(a, b) {
//   return a + b;
// };

// Function Expression создаётся, когда выполнение доходит до него, и затем уже может использоваться.

// После того, как поток выполнения достигнет правой части выражения присваивания let sum = function… – с этого момента, функция считается созданной и может быть использована (присвоена переменной, вызвана и т.д. ).

// С Function Declaration всё иначе.

// Function Declaration можно использовать во всем скрипте (или блоке кода, если функция объявлена в блоке).

// Другими словами, когда движок JavaScript готовится выполнять скрипт или блок кода, прежде всего он ищет в нём Function Declaration и создаёт все такие функции. Можно считать этот процесс «стадией инициализации».

// И только после того, как все объявления Function Declaration будут обработаны, продолжится выполнение.

// В результате, функции, созданные, как Function Declaration могут быть вызваны раньше своих определений.
// Функции, объявленные при помощи Function Expression, создаются тогда, когда выполнение доходит до них. Это случится только на строке, помеченной звёздочкой (*). Слишком поздно.

// Ещё одна важная особенность Function Declaration заключается в их блочной области видимости.

// В строгом режиме, когда Function Declaration находится в блоке {...}, функция доступна везде внутри блока. Но не снаружи него.

// let age = 16; // присвоим для примера 16

// if (age < 18) {
//   welcome();               // \   (выполнится)
//                            //  |
//   function welcome() {     //  |
//     alert("Привет!");      //  |  Function Declaration доступно
//   }                        //  |  во всём блоке кода, в котором объявлено
//                            //  |
//   welcome();               // /   (выполнится)

// } else {

//   function welcome() {
//     alert("Здравствуйте!");
//   }
// }

// здесь фигурная скобка закрывается,
// поэтому Function Declaration, созданные внутри блока кода выше -- недоступны отсюда.

//welcome(); // Ошибка: welcome is not defined

// Что можно сделать, чтобы welcome была видима снаружи if?

// Верным подходом будет воспользоваться функцией, объявленной при помощи Function Expression, и присвоить значение welcome переменной, объявленной снаружи if, что обеспечит нам нужную видимость.


// let age = prompt("Сколько Вам лет?", 18);

// let welcome;

// if (age < 18) {

//   welcome = function() {
//     alert("Привет!");
//   };

// } else {

//   welcome = function() {
//     alert("Здравствуйте!");
//   };

// }

// welcome(); // теперь всё в порядке
// Можно упростить этот код ещё сильнее, используя условный оператор ?:

// let age = prompt("Сколько Вам лет?", 18);

// let welcome = (age < 18) ?
//   function() { alert("Привет!"); } :
//   function() { alert("Здравствуйте!"); };

// welcome(); // теперь всё в порядке



// Когда использовать Function Declaration, а когда Function Expression?
// Как правило, если нам понадобилась функция, в первую очередь нужно рассматривать синтаксис Function Declaration, который мы использовали до этого. Он даёт нам больше свободы в том, как мы можем организовывать код. Функции, объявленные таким образом, можно вызывать до их объявления.

// Также функции вида function f(…) {…} чуть более заметны в коде, чем let f = function(…) {…}. Function Declaration легче «ловятся глазами».

// …Но если Function Declaration нам не подходит по какой-то причине (мы рассмотрели это в примере выше), то можно использовать объявление при помощи Function Expression.

// Итого
// Функции – это значения. Они могут быть присвоены, скопированы или объявлены в другом месте кода.
// Если функция объявлена как отдельная инструкция в основном потоке кода, то это Function Declaration.
// Если функция была создана как часть выражения, то считается, что эта функция объявлена при помощи Function Expression.
// Function Declaration обрабатываются перед выполнением блока кода. Они видны во всём блоке.
// Функции, объявленные при помощи Function Expression, создаются, только когда поток выполнения достигает их.
// В большинстве случаев, когда нам нужно создать функцию, предпочтительно использовать Function Declaration, т.к. функция будет видима до своего объявления в коде. Это позволяет более гибко организовывать код, и улучшает его читаемость.

// Таким образом, мы должны прибегать к объявлению функций при помощи Function Expression в случае, когда синтаксис Function Declaration не подходит для нашей задачи.



// Функции-стрелки, основы
// Существует ещё более простой и краткий синтаксис для создания функций, который часто лучше, чем синтаксис Function Expression.
// Он называется «функции-стрелки» или «стрелочные функции» (arrow functions), т.к. выглядит следующим образом:

// let func = (arg1, arg2, ...argN) => expression
// Такой код создаёт функцию func с аргументами arg1..argN и вычисляет expression с правой стороны с их использованием, возвращая результат.
// let sum = (a, b) => a + b;
// // console.log( sum(1, 2) );
// То есть, (a, b) => a + b задаёт функцию с двумя аргументами a и b, которая при запуске вычисляет выражение справа a + b и возвращает его результат.

// Если у нас только один аргумент, то круглые скобки вокруг параметров можно опустить, сделав запись ещё короче:

// // тоже что и
// // let double = function(n) { return n * 2 }
// let double = n => n * 2;

// alert( double(3) ); // 6
// Если нет аргументов, указываются пустые круглые скобки:

// let sayHi = () => alert("Hello!");

// sayHi();
// Функции-стрелки могут быть использованы так же, как и Function Expression.


// let age = prompt("Сколько Вам лет?", 18);

// let welcome = (age < 18) ?
//   () => alert('Привет') :
//   () => alert("Здравствуйте!");

// welcome(); // теперь всё в порядке
// Поначалу функции-стрелки могут показаться необычными и трудночитаемыми, но это быстро пройдёт, как только глаза привыкнут к этим конструкциям.

// Они очень удобны для простых однострочных действий, когда лень писать много букв.


// Многострочные стрелочные функции
// В примерах выше аргументы использовались слева от =>, а справа вычислялось выражение с их значениями.

// Порой нам нужно что-то посложнее, например, выполнить несколько инструкций. Это также возможно, нужно лишь заключить инструкции в фигурные скобки. И использовать return внутри них, как в обычной функции.
// let sum = (a, b) => {  // фигурная скобка, открывающая тело многострочной функции
//     let result = a + b;
//     return result; // при фигурных скобках для возврата значения нужно явно вызвать return
//   };
  
//   alert( sum(1, 2) ); // 3
































































